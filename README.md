# 01.01.2048
Этот репозиторий создан в честь моего проекта по программированию - игры 2048, на 1 курсе обучения в моем первом университете

Суть игры 2048: есть поле 4*4, изначально 2 рандомные ячейки из 16 заполнены двойкой и четверкой. Ход игрока = нажатие одной из 
клавиш: вверх, вниз, вправо, влево и добвление одной цифры в рандомную ячейку: двойки (с вероятностью 80%) или четверки (20%). 
Если 2 ячейки, принадлежащие одной строке или одному столбцу имеют одинаковые значения и между ними нет другой заполненной ячейки 
(например [2, 2, 0, 0] или [2, 0, 2, 2] или [2, 0, 2, 16]), то при нажатии клавиш влево/вправо (если они в строке) или вверх/вниз 
(если они в столбце) - две одинаковые ячейки схлопываются в одну с удвоенным значением: в самую правую, если был сделан ход 
направо, в самую верхнюю - если ход был сделан вверх и т.д. Таким образом могут быть получены ячейки 4, 8, 16, 32, 64, ... 2048,
4096 и т.д., то есть - степени двойки. Цель оригинальной игры: получить значение 2048 в одной ячейке, то есть 2^11. 
В моей версии игры нет определенной цели, главное - набрать как можно большее число в ячейке и общую сумму за раунд.

В самом начале игры в двух рандомных клетках появляются двойка и четверка с вероятностями 80% и 20% сооответственно:
def insert_2_or_4(l,x,y):        #функция, вставляющая двойку или четверку в массив
    if random.random()<=0.8:    #так как в оригинальной игре двойка выпадает чаще, чем четверка, увеличим вероятность выпадения двойки с 50% до 80%
        l[x][y] = 2
    else:
        l[x][y] = 4
    return l
    
для этого можно использовать функцию:
def get_number_from_index(i, j): #функция, которая принимает номер строки и номер столбцами возвращает порядковый номер элемента
    return i * 4 + j + 1
#а также обратную ей:
def get_index_from_number(num):  #функция, которая по числу выдает координаты ячейки
    num -= 1
    x,y = num // 4, num % 4
    return x,y
    
Движение ячеек в основном построены с помощью методов списков, для примера, функция движения влево:
def move_left(l):
    delta = 0 #переменная, обозначающая изменения
    for row in l:
        while 0 in row:
            row.remove(0)
        while len(row) != 4:
            row.append(0)
    for i in range(4):
        for j in range(3):
            if l[i][j] == l[i][j + 1] and l[i][j] != 0:
                l[i][j] *= 2
                delta += l[i][j] #каждый раз, когда две ячейки складываются в одну, delta записывает в себя значение получившейся ячейки
                l[i].pop(j + 1)
                l[i].append(0)
    return l, delta
    
Также, в игре есть много интересных деталей: 
1) intro - приветствие игрока, где он может ввести свое имя, чтобы если он побьет рекорд его результат сохранился, 
а следовательно - 
2) база данных, куда сохраняются и где сортируются от большего к меньшему результаты, написанная с помощью SQL и приложения 
DB Browser for SQLite. Чтобы было, что сортировать, конечно есть -
3) текущий счет игрока: score - общая сумма всех суммированных ячеек, по ней и устанавливается рекорд, а в конце игры есть
4) outro - появляется, если выхода из массива нет: все ячейки заполнены и двигаться некуда, игроку показывается его счет и
пометка, побил ли он рекорд.

Далее пример логики intro:

#обработка текста после приветствия:
Если нажата кнопка, которая отвечает за буквы (обозначает букву), то мы добавляем букву
Если нажат backspace, то удаляется последний элемент строки

for event in pygame.event.get():
    if event.type == pygame.QUIT:
        pygame.quit()
        sys.exit(0)

#если нажата буква, то к строке добавляем букву:
elif event.type == pygame.KEYDOWN:   #если мы нажали на клавиатуру
    if event.unicode.isalpha():
        if name == 'Введите имя':
            name = event.unicode  #если name == вв. имя, то ввод начинается с нуля
        else:
            name += event.unicode  #если name != вв. имя, то просто добавляем букву
            
#если нажат backspace, то есть удаляется последний элемент строки, используем срезы списков:
elif event.key == pygame.K_BACKSPACE:
    name = name[:-1]
  
  
Если нажата клавиша enter, то программа должна проверять: ввел ли игрок имя
Если длина строки, введенной пользователем больше двух элементов, то все хорошо, глобальная переменная с изначальным названием 
None принимает значение этой строки и получается имя пользователя

elif event.key == pygame.K_RETURN:
    if len(name) > 2:
        global USERNAME
        USERNAME = name
